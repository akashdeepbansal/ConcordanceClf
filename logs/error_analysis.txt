2: Let   MATH   be a continuous function. The 
 : [array(['the', 'math be', 'math', 'let math', 'let', 'function',
       'continuous function', 'continuous', 'be'], dtype='<U24')],
 true: 1, pred: 0
5:  the length of the code   MATH   is  MATH . Observe that   MATH 
 : [array(['the length', 'the code', 'the', 'that math', 'that', 'of the',
       'of', 'observe that', 'observe', 'math observe', 'math is', 'math',
       'length of', 'length', 'is math', 'is', 'code math', 'code'],
      dtype='<U24')],
 true: 1, pred: 0
10:  the notation  MATH  means that   MATH   and  MATH .
 : [array(['the notation', 'the', 'that math', 'that', 'notation math',
       'notation', 'means that', 'means', 'math and', 'math', 'and math',
       'and'], dtype='<U24')],
 true: 1, pred: 0
18:  write  MATH  for a vector   MATH   with  MATH  . Then we have 
 : [array(['write math', 'write', 'with math', 'with', 'we have', 'we',
       'vector', 'then we', 'then', 'math with', 'math then', 'math for',
       'math', 'have', 'for'], dtype='<U24')],
 true: 1, pred: 0
25:  and  M is Clifford torus  MATH  .
 : [array(['torus math', 'torus', 'math', 'is clifford', 'is',
       'clifford torus', 'clifford', 'and is', 'and'], dtype='<U24')],
 true: 0, pred: 1
32:  every pair of distinct elements   MATH   and  MATH  in  MATH  . We 
 : [array(['we', 'pair of', 'pair', 'of distinct', 'of', 'math we', 'math in',
       'math and', 'math', 'in math', 'in', 'every pair', 'every',
       'elements math', 'elements', 'distinct elements', 'distinct',
       'and math', 'and'], dtype='<U24')],
 true: 0, pred: 1
45:  But since only the points   MATH   with  MATH  will be involved 
 : [array(['with math', 'with', 'will be', 'will', 'the points', 'the',
       'since', 'points math', 'points', 'only', 'math with', 'math will',
       'math', 'but', 'be'], dtype='<U24')],
 true: 1, pred: 0
46:  two new operators  MATH  and   MATH   by MATH  We note that 
 : [array(['we', 'two', 'that', 'operators', 'note that', 'note', 'new',
       'math we', 'math by', 'math and', 'math', 'by math', 'by',
       'and math', 'and'], dtype='<U24')],
 true: 1, pred: 0
50:  inward normal of  MATH , and   MATH   tangent vector to  MATH  , perpendicular 
 : [array(['vector', 'to math', 'to', 'tangent', 'of math', 'of', 'normal',
       'math and', 'math', 'and math', 'and'], dtype='<U24')],
 true: 1, pred: 0
63:  ρ   stands for the density,   MATH   the velocity,  MATH  the deformation 
 : [array(['velocity', 'the velocity', 'the', 'math the', 'math', 'for the',
       'for'], dtype='<U24')],
 true: 1, pred: 0
73:  considers a general measure datum   MATH   , not necessarily belonging to the 
 : [array(['to the', 'to', 'the', 'not', 'measure', 'math', 'general'],
      dtype='<U24')],
 true: 1, pred: 0
82:  the supersonic flow field ahead   MATH  , and  MATH  the subsonic flow 
 : [array(['the', 'supersonic', 'math the', 'math and', 'math', 'flow',
       'field', 'and math', 'and'], dtype='<U24')],
 true: 0, pred: 1
83:  MATH  for every smooth function  MATH  . Moreover, MATH  has polynomial component 
 : [array(['smooth function', 'smooth', 'polynomial', 'moreover',
       'math moreover', 'math has', 'math for', 'math', 'has',
       'function math', 'function', 'for every', 'for', 'every',
       'component'], dtype='<U24')],
 true: 1, pred: 0
90:  MATH   with the new one   MATH   such that  MATH 
 : [array(['with the', 'with', 'the new', 'the', 'that math', 'that',
       'such that', 'such', 'one', 'new', 'math with', 'math such',
       'math'], dtype='<U24')],
 true: 1, pred: 0
92:  in  MATH  with its boundaries   MATH   as in  Fig. 4.1  :  MATH 
 : [array(['with its', 'with', 'math with', 'math as', 'math', 'its',
       'in math', 'in', 'fig', 'boundaries math', 'boundaries', 'as in',
       'as'], dtype='<U24')],
 true: 1, pred: 0
94:  linear code over  MATH  by   MATH 
 : [array(['over math', 'over', 'math by', 'math', 'linear code', 'linear',
       'code over', 'code', 'by math', 'by'], dtype='<U24')],
 true: 0, pred: 1
97:  the intersection points  A  and   MATH   coincide with  MATH  ; and when 
 : [array(['with math', 'with', 'when', 'the', 'points', 'math and', 'math',
       'and math', 'and'], dtype='<U24')],
 true: 1, pred: 0
107:  image under the Fricke involution   MATH  . As  MATH  for all   MATH 
 : [array(['under the', 'under', 'the', 'math for', 'math as', 'math',
       'involution math', 'involution', 'image', 'for all', 'for',
       'as math', 'as', 'all math', 'all'], dtype='<U24')],
 true: 1, pred: 0
121: Let   MATH   be the homogeneous dimension of 
 : [array(['the homogeneous', 'the', 'of', 'math be', 'math', 'let math',
       'let', 'homogeneous', 'dimension of', 'dimension', 'be the', 'be'],
      dtype='<U24')],
 true: 1, pred: 0
123:  paper, denote the Gauss sum   MATH   over  MATH  by  MATH .
 : [array(['the', 'sum', 'paper', 'over math', 'over', 'math over', 'math by',
       'math', 'denote the', 'denote', 'by math', 'by'], dtype='<U24')],
 true: 1, pred: 0
134:  in the weighted Hölder space   MATH   for any admissible weight   MATH 
 : [array(['weighted', 'weight math', 'weight', 'the weighted', 'the',
       'space math', 'space', 'math for', 'math', 'in the', 'in',
       'hölder', 'for any', 'for', 'any admissible', 'any',
       'admissible weight', 'admissible'], dtype='<U24')],
 true: 1, pred: 0
135:  the background transonic shock solution   MATH  , we have MATH  and the 
 : [array(['we have', 'we', 'transonic shock', 'transonic', 'the',
       'solution math', 'solution', 'shock solution', 'shock', 'math we',
       'math and', 'math', 'have math', 'have', 'and the', 'and'],
      dtype='<U24')],
 true: 0, pred: 1
144:  the more general Besov space   MATH  , built up of  MATH  functions 
 : [array(['up', 'the', 'space math', 'space', 'of math', 'of', 'more',
       'math', 'general', 'functions'], dtype='<U24')],
 true: 1, pred: 0
148:  We still consider the sequence   MATH   defined by  (4.1)  . Observe that 
 : [array(['we still', 'we', 'the sequence', 'the', 'that', 'still',
       'sequence math', 'sequence', 'observe that', 'observe',
       'math defined', 'math', 'defined by', 'defined', 'consider the',
       'consider', 'by'], dtype='<U24')],
 true: 0, pred: 1
164:  3   we have MATH  Since   MATH   is holomorphic,  MATH  . So, from 
 : [array(['we have', 'we', 'so', 'since math', 'since', 'math so',
       'math since', 'math is', 'math', 'is holomorphic', 'is',
       'holomorphic', 'have math', 'have', 'from'], dtype='<U24')],
 true: 1, pred: 0
178:  of  MATH  over  MATH . Let   MATH   be a basis of   MATH 
 : [array(['over math', 'over', 'of math', 'of', 'math over', 'math let',
       'math be', 'math', 'let math', 'let', 'be basis', 'be', 'basis of',
       'basis'], dtype='<U24')],
 true: 1, pred: 0
179:  MATH   in the Heisenberg group   MATH   , whose boundary is homeomorphic to 
 : [array(['to', 'the', 'math in', 'math', 'is', 'in the', 'in', 'group math',
       'group', 'boundary'], dtype='<U24')],
 true: 1, pred: 0
182:  integers. We define the operation   MATH   by MATH  For  MATH  , by 
 : [array(['we define', 'we', 'the', 'math for', 'math by', 'math',
       'integers', 'for math', 'for', 'define the', 'define', 'by math',
       'by'], dtype='<U24')],
 true: 1, pred: 0
185: Let  MATH  be a  non-negative bounded function 
 : [array(['non', 'negative', 'math be', 'math', 'let math', 'let',
       'function', 'bounded function', 'bounded', 'be'], dtype='<U24')],
 true: 1, pred: 0
201:  (3.23)   of  Lemma 3.3  with   MATH   , we would get the weaker 
 : [array(['with math', 'with', 'we', 'the', 'of', 'math we', 'math', 'lemma',
       'get the', 'get', '23'], dtype='<U24')],
 true: 1, pred: 0
217:  Besov–Nikol'skii estimate  MATH for some  MATH   . In particular, we have the 
 : [array(['we have', 'we', 'the', 'some math', 'some', 'particular',
       'math in', 'math for', 'math', 'in particular', 'in', 'have the',
       'have', 'for some', 'for', 'estimate math', 'estimate'],
      dtype='<U24')],
 true: 1, pred: 0
220: Note that  MATH Since   MATH   is a basis of   MATH 
 : [array(['that math', 'that', 'since math', 'since', 'of math', 'of',
       'note that', 'note', 'math since', 'math is', 'math', 'is basis',
       'is', 'basis of', 'basis'], dtype='<U24')],
 true: 1, pred: 0
235:  if  MATH  where  u  and   MATH   are harmonic functions in   D 
 : [array(['where', 'math where', 'math are', 'math', 'in', 'if math', 'if',
       'harmonic', 'functions in', 'functions', 'are', 'and math', 'and'],
      dtype='<U24')],
 true: 1, pred: 0
239:  and outgoing modes of  MATH ,   MATH   and  H  are both   MATH 
 : [array(['of math', 'of', 'modes', 'math math', 'math and', 'math',
       'both math', 'both', 'are both', 'are', 'and are', 'and'],
      dtype='<U24')],
 true: 0, pred: 1
240:  MATH   gives us MATH  Since   MATH   is a Willmore hypersurface,   MATH 
 : [array(['willmore hypersurface', 'willmore', 'us math', 'us', 'since math',
       'since', 'math since', 'math is', 'math gives', 'math', 'is',
       'hypersurface math', 'hypersurface', 'gives us', 'gives'],
      dtype='<U24')],
 true: 1, pred: 0
244:  the constants  MATH ,  MATH ,  MATH ,   MATH  ,  MATH ,  MATH  and  MATH  satisfy 
 : [array(['the constants', 'the', 'satisfy', 'math satisfy', 'math math',
       'math and', 'math', 'constants math', 'constants', 'and math',
       'and'], dtype='<U24')],
 true: 1, pred: 0
249:  behind the shock-front on the   MATH  -D hyperplane  MATH ; see   Fig. 
 : [array(['the shock', 'the math', 'the', 'shock front', 'shock', 'see fig',
       'see', 'on the', 'on', 'math see', 'math', 'front', 'fig',
       'behind'], dtype='<U24')],
 true: 0, pred: 1
257:  as  MATH . We thus get  MATH  Conclusion.  From  (3.4)  we have 
 : [array(['we have', 'we', 'thus', 'math we', 'math', 'have', 'get math',
       'get', 'from we', 'from', 'as math', 'as'], dtype='<U24')],
 true: 1, pred: 0
261:  value problem  MATH MATH has  MATH  solution MATH  in the class 
 : [array(['value problem', 'value', 'the class', 'the', 'solution math',
       'solution', 'problem math', 'problem', 'math math', 'math in',
       'math has', 'math', 'in the', 'in', 'has math', 'has', 'class'],
      dtype='<U24')],
 true: 0, pred: 1
263: Since the parameter   MATH   is much greater than   MATH 
 : [array(['the', 'than math', 'than', 'since the', 'since', 'parameter math',
       'parameter', 'math is', 'math', 'is'], dtype='<U24')],
 true: 1, pred: 0
268:  form  MATH is called a   MATH  - polynomial  (or a   linearized polynomial 
 : [array(['polynomial', 'or', 'math is', 'math', 'linearized polynomial',
       'linearized', 'is called', 'is', 'form math', 'form', 'called'],
      dtype='<U24')],
 true: 0, pred: 1
274:  we have  MATH  for all   MATH   and  MATH . By  (6.3)  , we 
 : [array(['we have', 'we', 'math for', 'math by', 'math and', 'math',
       'have math', 'have', 'for all', 'for', 'by we', 'by', 'and math',
       'and', 'all math', 'all'], dtype='<U24')],
 true: 1, pred: 0
278:  case follows by normalization. Let   MATH   be an arc length parametrization 
 : [array(['math be', 'math', 'let math', 'let', 'length', 'follows', 'case',
       'by', 'be an', 'be', 'an'], dtype='<U24')],
 true: 1, pred: 0
281:  that, for an M-D wedge   MATH   , the weak transonic shock solution, 
 : [array(['wedge', 'weak transonic', 'weak', 'transonic shock', 'transonic',
       'the weak', 'the', 'that for', 'that', 'solution',
       'shock solution', 'shock', 'math the', 'math', 'for', 'an'],
      dtype='<U24')],
 true: 0, pred: 1
285:  our main result. The parameter   MATH   below measures the degree of 
 : [array(['the', 'result', 'parameter math', 'parameter', 'our', 'of',
       'math below', 'math', 'degree', 'below'], dtype='<U24')],
 true: 1, pred: 0
286:  get  MATH  By recalling that   MATH  , using  (A.5)  and taking the 
 : [array(['using', 'the', 'that math', 'that', 'taking the', 'taking',
       'recalling that', 'recalling', 'math using', 'math by', 'math',
       'get math', 'get', 'by recalling', 'by', 'and'], dtype='<U24')],
 true: 1, pred: 0
289:  sub-Laplacian  MATH , i.e. MATH  and   MATH   is a solution of  MATH 
 : [array(['sub laplacian', 'sub', 'solution of', 'solution', 'of math', 'of',
       'math math', 'math is', 'math and', 'math', 'laplacian math',
       'laplacian', 'is', 'and math', 'and'], dtype='<U24')],
 true: 0, pred: 1
294:  the sub-Laplacian  MATH  on  MATH ,  MATH   see  (3.1)  for its formula. 
 : [array(['the sub', 'the', 'sub laplacian', 'sub', 'see', 'on math', 'on',
       'math see', 'math on', 'math math', 'math', 'laplacian math',
       'laplacian', 'its', 'formula', 'for'], dtype='<U24')],
 true: 0, pred: 1
305:  in  MATH  is a function   MATH   such that  MATH 
 : [array(['that math', 'that', 'such that', 'such', 'math such', 'math is',
       'math', 'is', 'in math', 'in', 'function math', 'function'],
      dtype='<U24')],
 true: 1, pred: 0
323:  under the assumption in Case   MATH  Then we have MATH
 : [array(['we have', 'we', 'under the', 'under', 'then we', 'then', 'the',
       'math then', 'math', 'in case', 'in', 'have math', 'have',
       'case math', 'case', 'assumption'], dtype='<U24')],
 true: 1, pred: 0
326:  MATH  . When  MATH , the character   MATH   in  (6)  is called the 
 : [array(['when math', 'when', 'the', 'math when', 'math the', 'math in',
       'math', 'is called', 'is', 'in is', 'in', 'character math',
       'character', 'called the', 'called'], dtype='<U24')],
 true: 1, pred: 0
329:  such that  MATH  for all   MATH   and  MATH , where  MATH  is 
 : [array(['where math', 'where', 'that math', 'that', 'such that', 'such',
       'math where', 'math is', 'math for', 'math and', 'math', 'is',
       'for all', 'for', 'and math', 'and', 'all math', 'all'],
      dtype='<U24')],
 true: 1, pred: 0
336:  operators, where the singular kernel   MATH   is replaced by some slight 
 : [array(['where the', 'where', 'the', 'some', 'operators', 'math is',
       'math', 'kernel math', 'kernel', 'is', 'by'], dtype='<U24')],
 true: 1, pred: 0
340:  stable, except the critical point   MATH   (see  [7,15]  ). Moreover, for the 
 : [array(['the', 'stable', 'see', 'point math', 'point', 'moreover',
       'math see', 'math', 'for the', 'for', 'except', 'critical', '15'],
      dtype='<U24')],
 true: 1, pred: 0
345:  (a) For some natural numbers   MATH   the decomposition  MATH  is valid, 
 : [array(['valid', 'the', 'some', 'numbers', 'natural', 'math the',
       'math is', 'math', 'is', 'for some', 'for'], dtype='<U24')],
 true: 1, pred: 0
351:  net in the complete space   MATH   . Thus there exists a sequence 
 : [array(['thus', 'there exists', 'there', 'the', 'space math', 'space',
       'sequence', 'math thus', 'math', 'in the', 'in', 'exists'],
      dtype='<U24')],
 true: 1, pred: 0
357:  overview of them). The function   MATH   is a modular form of 
 : [array(['the function', 'the', 'of', 'modular', 'math is', 'math', 'is',
       'function math', 'function', 'form'], dtype='<U24')],
 true: 1, pred: 0
364: Let  MATH   be the weak transonic shock 
 : [array(['weak transonic', 'weak', 'transonic shock', 'transonic',
       'the weak', 'the', 'shock', 'math be', 'math', 'let math', 'let',
       'be the', 'be'], dtype='<U24')],
 true: 0, pred: 1
369: Let  MATH  and let   MATH   be an eta quotient on 
 : [array(['quotient on', 'quotient', 'on', 'math be', 'math and', 'math',
       'let math', 'let', 'eta quotient', 'eta', 'be an', 'be', 'and let',
       'and', 'an eta', 'an'], dtype='<U24')],
 true: 1, pred: 0
371: The Gauss sum   MATH   over  MATH  is defined by 
 : [array(['the', 'sum', 'over math', 'over', 'math over', 'math is', 'math',
       'is defined', 'is', 'defined by', 'defined', 'by'], dtype='<U24')],
 true: 1, pred: 0
386:  reduced to  MATH  where   MATH   is a  MATH  matrix whose 
 : [array(['where math', 'where', 'to math', 'to', 'reduced', 'matrix',
       'math where', 'math is', 'math', 'is math', 'is'], dtype='<U24')],
 true: 1, pred: 0
391:  dν   the volume element on   MATH  ,  MATH  left-invariant vector fields in 
 : [array(['vector fields', 'vector', 'the', 'on math', 'on', 'math math',
       'math', 'left invariant', 'left', 'invariant vector', 'invariant',
       'in', 'fields', 'element'], dtype='<U24')],
 true: 0, pred: 1
397:  to the unique solution of   MATH 
 : [array(['unique solution', 'unique', 'to the', 'to', 'the unique', 'the',
       'solution of', 'solution', 'of math', 'of', 'math'], dtype='<U24')],
 true: 0, pred: 1
399:  an open domain of class   MATH  . A point  MATH  is called 
 : [array(['point math', 'point', 'open', 'of class', 'of', 'math is', 'math',
       'is called', 'is', 'domain of', 'domain', 'class math', 'class',
       'called', 'an open', 'an'], dtype='<U24')],
 true: 1, pred: 0
400:  the derivative of the function   MATH   gives us MATH  Since   M 
 : [array(['us math', 'us', 'the function', 'the derivative', 'the', 'since',
       'of the', 'of', 'math since', 'math gives', 'math', 'gives us',
       'gives', 'function math', 'function', 'derivative of',
       'derivative'], dtype='<U24')],
 true: 1, pred: 0
413: Moreover, since   MATH   is a diffeomorphism, for   n 
 : [array(['since math', 'since', 'moreover', 'math is', 'math',
       'is diffeomorphism', 'is', 'for', 'diffeomorphism'], dtype='<U24')],
 true: 1, pred: 0
415:  shock solution  MATH , we have  MATH   and the corresponding partial hodograph 
 : [array(['we have', 'we', 'the corresponding', 'the', 'solution math',
       'solution', 'shock solution', 'shock', 'partial hodograph',
       'partial', 'math we', 'math and', 'math', 'hodograph', 'have math',
       'have', 'corresponding', 'and the', 'and'], dtype='<U24')],
 true: 0, pred: 1
432:  cut-off function  MATH  such that  MATH   By taking into account   (4.3) 
 : [array(['that math', 'that', 'taking', 'such that', 'such', 'off function',
       'off', 'math such', 'math by', 'math', 'into', 'function math',
       'function', 'cut off', 'cut', 'by'], dtype='<U24')],
 true: 1, pred: 0
447:  any closed minimal Willmore hypersurface   MATH   of  MATH  with constant scalar 
 : [array(['with constant', 'with', 'willmore hypersurface', 'willmore',
       'scalar', 'of math', 'of', 'minimal willmore', 'minimal',
       'math with', 'math of', 'math', 'hypersurface math',
       'hypersurface', 'constant scalar', 'constant', 'closed minimal',
       'closed', 'any'], dtype='<U24')],
 true: 1, pred: 0
449:  column of the deformation gradient   MATH  ,  MATH  . In column-wise components, the 
 : [array(['the', 'of the', 'of', 'math math', 'math in', 'math', 'in',
       'gradient', 'components', 'column of', 'column'], dtype='<U24')],
 true: 1, pred: 0
466:  For  MATH  and  MATH , by   MATH   we denote the projection map, 
 : [array(['we denote', 'we', 'the', 'math we', 'math by', 'math and', 'math',
       'map', 'for math', 'for', 'denote the', 'denote', 'by math', 'by',
       'and math', 'and'], dtype='<U24')],
 true: 1, pred: 0
467:  MATH  . For an open set   MATH  , we denote by  MATH  the 
 : [array(['we denote', 'we', 'the', 'set math', 'set', 'open set', 'open',
       'math we', 'math the', 'math for', 'math', 'for', 'denote by',
       'denote', 'by math', 'by', 'an open', 'an'], dtype='<U24')],
 true: 0, pred: 1
473:  condition on the wedge boundary   MATH  : MATH  where, with   MATH 
 : [array(['with math', 'with', 'where', 'wedge', 'the wedge', 'the',
       'on the', 'on', 'math where', 'math math', 'math', 'condition',
       'boundary math', 'boundary'], dtype='<U24')],
 true: 1, pred: 0
478:  all  MATH  and  MATH , where   MATH   is a positive constant depending 
 : [array(['where math', 'where', 'positive constant', 'positive',
       'math where', 'math is', 'math and', 'math', 'is positive', 'is',
       'depending', 'constant', 'and math', 'and', 'all math', 'all'],
      dtype='<U24')],
 true: 1, pred: 0
480:  use that  MATH  and again   MATH  ) MATH  where  MATH  as usual 
 : [array(['where math', 'where', 'usual', 'use', 'that math', 'that',
       'math where', 'math math', 'math as', 'math and', 'math',
       'as usual', 'as', 'and', 'again'], dtype='<U24')],
 true: 1, pred: 0
481:  the following form:  MATH  where   MATH   is the  j  th column 
 : [array(['where math', 'where', 'the th', 'the following', 'the',
       'th column', 'th', 'math where', 'math is', 'math', 'is the', 'is',
       'form math', 'form', 'following form', 'following', 'column'],
      dtype='<U24')],
 true: 1, pred: 0
486:  exists an increasing continuous function   MATH   such that MATH  In the 
 : [array(['the', 'that math', 'that', 'such that', 'such', 'math such',
       'math in', 'math', 'increasing', 'in the', 'in', 'function math',
       'function', 'exists', 'continuous function', 'continuous', 'an'],
      dtype='<U24')],
 true: 1, pred: 0
488:  MATH  MATH has a solution  MATH   in the class of functions 
 : [array(['the class', 'the', 'solution math', 'solution', 'of functions',
       'of', 'math math', 'math in', 'math has', 'math', 'in the', 'in',
       'has', 'functions', 'class of', 'class'], dtype='<U24')],
 true: 0, pred: 1
492:  Section  6 , for all integers   MATH  .
 : [array(['section', 'math', 'integers', 'for all', 'for', 'all'],
      dtype='<U24')],
 true: 1, pred: 0
496:  minimum (Hamming) distance  MATH . Let   MATH   denote the number of codewords 
 : [array(['the number', 'the', 'of', 'number of', 'number', 'minimum',
       'math let', 'math denote', 'math', 'let math', 'let', 'hamming',
       'distance', 'denote the', 'denote'], dtype='<U24')],
 true: 1, pred: 0
512: We have MATH  where   MATH   is a ball such that 
 : [array(['where math', 'where', 'we have', 'we', 'that', 'such that',
       'such', 'math where', 'math is', 'math', 'is', 'have math', 'have'],
      dtype='<U24')],
 true: 1, pred: 0
514:  A  , and  MATH  when point   MATH   coincides with point  B  . That 
 : [array(['with', 'when', 'that', 'point math', 'point', 'math when', 'math',
       'coincides with', 'coincides', 'and math', 'and'], dtype='<U24')],
 true: 1, pred: 0
521:  under the assumptions in Case   MATH  Then we have MATH  MATH 
 : [array(['we have', 'we', 'under the', 'under', 'then we', 'then', 'the',
       'math then', 'math math', 'math', 'in case', 'in', 'have math',
       'have', 'case math', 'case', 'assumptions'], dtype='<U24')],
 true: 1, pred: 0
524:  defined as before. Assume that   MATH   and  MATH  are dual bases. 
 : [array(['that math', 'that', 'math are', 'math and', 'math', 'dual bases',
       'dual', 'defined as', 'defined', 'before', 'bases', 'assume that',
       'assume', 'as before', 'as', 'are dual', 'are', 'and math', 'and'],
      dtype='<U24')],
 true: 1, pred: 0
526:  near the background potential function   MATH   . This can be achieved by 
 : [array(['this', 'the', 'potential', 'near the', 'near', 'math this',
       'math', 'function math', 'function', 'can be', 'can', 'by', 'be'],
      dtype='<U24')],
 true: 1, pred: 0
531:  7  7Indeed, observe that γi0<(1+t+sp)/p.  MATH   Thus, we have to proceed 
 : [array(['we have', 'we', 'to', 'thus we', 'thus', 'that', 'proceed',
       'observe that', 'observe', 'math thus', 'math', 'have'],
      dtype='<U24')],
 true: 1, pred: 0
532:  a  MATH linear code over  MATH   with the weight distribution in 
 : [array(['with the', 'with', 'weight distribution', 'weight', 'the weight',
       'the', 'over math', 'over', 'math with', 'math linear', 'math',
       'linear code', 'linear', 'in', 'distribution in', 'distribution',
       'code over', 'code'], dtype='<U24')],
 true: 0, pred: 1
542:  called a domain of class   MATH   if for each  MATH  there 
 : [array(['there', 'of class', 'of', 'math there', 'math if', 'math', 'if',
       'for each', 'for', 'each math', 'each', 'domain of', 'domain',
       'class math', 'class', 'called'], dtype='<U24')],
 true: 1, pred: 0
547:  MATH   the completion of set   MATH   under norm  (4.1) .
 : [array(['under norm', 'under', 'the completion', 'the', 'set math', 'set',
       'of set', 'of', 'norm', 'math under', 'math the', 'math',
       'completion of', 'completion'], dtype='<U24')],
 true: 0, pred: 1
558:  of  MATH  over  MATH  and   MATH   be a basis of   MATH 
 : [array(['over math', 'over', 'of math', 'of', 'math over', 'math be',
       'math and', 'math', 'be basis', 'be', 'basis of', 'basis',
       'and math', 'and'], dtype='<U24')],
 true: 1, pred: 0
559:  velocity behind the shock-front is   MATH   where  MATH  is the angle 
 : [array(['where math', 'where', 'velocity', 'the shock', 'the',
       'shock front', 'shock', 'math where', 'math is', 'math', 'is the',
       'is math', 'is', 'front', 'behind', 'angle'], dtype='<U24')],
 true: 0, pred: 1
562:  linear code over  MATH  by   MATH 
 : [array(['over math', 'over', 'math by', 'math', 'linear code', 'linear',
       'code over', 'code', 'by math', 'by'], dtype='<U24')],
 true: 0, pred: 1
567:  exists a prime  p  dividing   MATH   such that MATH  where  MATH 
 : [array(['where math', 'where', 'that math', 'that', 'such that', 'such',
       'prime', 'math where', 'math such', 'math', 'exists',
       'dividing math', 'dividing'], dtype='<U24')],
 true: 0, pred: 1
574:  β   that MATH  for all   MATH   and  MATH . By  (6.3)  , we 
 : [array(['we', 'that math', 'that', 'math for', 'math by', 'math and',
       'math', 'for all', 'for', 'by we', 'by', 'and math', 'and',
       'all math', 'all'], dtype='<U24')],
 true: 1, pred: 0
580:  results of this paper. Let   MATH   be a homogeneous Carnot group 
 : [array(['this paper', 'this', 'paper', 'of', 'math be', 'math', 'let math',
       'let', 'homogeneous carnot', 'homogeneous', 'group',
       'carnot group', 'carnot', 'be'], dtype='<U24')],
 true: 1, pred: 0
583:  polytropic gases of adiabatic exponent   MATH   by scaling, and  MATH  is 
 : [array(['of', 'math is', 'math by', 'math', 'is', 'exponent math',
       'exponent', 'by', 'and math', 'and'], dtype='<U24')],
 true: 1, pred: 0
591:  MATH   (see  [15] ), MATH  and   MATH   is homogeneous of degree   MATH 
 : [array(['see', 'of degree', 'of', 'math see', 'math is', 'math and',
       'math', 'is homogeneous', 'is', 'homogeneous of', 'homogeneous',
       'degree math', 'degree', 'and math', 'and', '15'], dtype='<U24')],
 true: 0, pred: 1
592:  that  MATH  is continuous if   MATH   is a Lipschitz weak homeomorphism 
 : [array(['weak', 'that math', 'that', 'math is', 'math', 'lipschitz',
       'is continuous', 'is', 'if math', 'if', 'homeomorphism',
       'continuous'], dtype='<U24')],
 true: 1, pred: 0
613:  exist positive numbers  a  and   MATH   such that  MATH  is nondecreasing 
 : [array(['that math', 'that', 'such that', 'such', 'positive', 'numbers',
       'math such', 'math is', 'math', 'is', 'exist', 'and math', 'and'],
      dtype='<U24')],
 true: 1, pred: 0
616:  intersection curve exists; see loop   MATH   in  Fig. 2.1 (b).
 : [array(['see', 'math in', 'math', 'in', 'fig', 'exists', 'curve'],
      dtype='<U24')],
 true: 1, pred: 0
631:  determined by the intersection points   MATH   and  B  of loop   MATH 
 : [array(['the', 'points math', 'points', 'of', 'math and', 'math',
       'determined by', 'determined', 'by the', 'by', 'and'], dtype='<U24')],
 true: 1, pred: 0
634:  MATH   cut-off function, such that   MATH   on  MATH . By choosing   MATH 
 : [array(['that math', 'that', 'such that', 'such', 'on math', 'on',
       'off function', 'off', 'math on', 'math cut', 'math by', 'math',
       'function such', 'function', 'cut off', 'cut', 'choosing math',
       'choosing', 'by'], dtype='<U24')],
 true: 1, pred: 0
636:  MATH  , and  MATH  for multi-index   MATH  . Denote by  MATH  the completion 
 : [array(['the completion', 'the', 'math the', 'math for', 'math denote',
       'math and', 'math', 'index math', 'index', 'for', 'denote by',
       'denote', 'completion', 'by math', 'by', 'and math', 'and'],
      dtype='<U24')],
 true: 1, pred: 0
642:  and  MATH  with  MATH ,  MATH ,   MATH   the inward normal of   MATH 
 : [array(['with math', 'with', 'the', 'of math', 'of', 'normal', 'math with',
       'math the', 'math math', 'math', 'and math', 'and'], dtype='<U24')],
 true: 1, pred: 0
651: Let  MATH  and   MATH   , we want to prove the 
 : [array(['we want', 'we', 'want', 'to prove', 'to', 'the', 'prove',
       'math we', 'math and', 'math', 'let math', 'let', 'and math',
       'and'], dtype='<U24')],
 true: 1, pred: 0
656:  any bounded domain of class   MATH   in the Heisenberg group   MATH 
 : [array(['the', 'of class', 'of', 'math in', 'math', 'in the', 'in',
       'group math', 'group', 'domain of', 'domain', 'class math',
       'class', 'bounded domain', 'bounded', 'any'], dtype='<U24')],
 true: 1, pred: 0
657:  A  closed minimal Willmore hypersurface  MATH  of MATH  with nonnegative constant 
 : [array(['with', 'willmore hypersurface', 'willmore', 'of math', 'of',
       'nonnegative', 'minimal willmore', 'minimal', 'math with',
       'math of', 'math', 'hypersurface math', 'hypersurface', 'constant',
       'closed minimal', 'closed'], dtype='<U24')],
 true: 1, pred: 0
660:  is regular of valency  MATH  MATH   and it has the following 
 : [array(['the following', 'the', 'regular', 'of', 'math math', 'math and',
       'math', 'it', 'is', 'has the', 'has', 'following', 'and'],
      dtype='<U24')],
 true: 1, pred: 0
663:  A polynomial of the form   MATH  is called a  MATH -  polynomial 
 : [array(['the form', 'the', 'polynomial', 'of the', 'of', 'math is', 'math',
       'is called', 'is', 'form math', 'form', 'called'], dtype='<U24')],
 true: 0, pred: 1
672:  potential  MATH is continuous on  MATH  , for all MATH .
 : [array(['potential math', 'potential', 'on math', 'on', 'math is',
       'math for', 'math', 'is continuous', 'is', 'for all', 'for',
       'continuous', 'all math', 'all'], dtype='<U24')],
 true: 0, pred: 1
676:  Frobenius mapping. For Niho exponents   MATH  , we restrict  MATH  in the 
 : [array(['we', 'the', 'niho', 'math we', 'math in', 'math', 'mapping',
       'in the', 'in', 'for'], dtype='<U24')],
 true: 1, pred: 0
677:  MATH  . We extend  MATH  to   MATH   which is a basis of 
 : [array(['which is', 'which', 'we extend', 'we', 'to math', 'to', 'of',
       'math which', 'math we', 'math to', 'math', 'is basis', 'is',
       'extend math', 'extend', 'basis of', 'basis'], dtype='<U24')],
 true: 1, pred: 0
679:  we define the eta quotient   MATH   by MATH  where  MATH  is 
 : [array(['where math', 'where', 'we define', 'we', 'the eta', 'the',
       'quotient math', 'quotient', 'math where', 'math is', 'math by',
       'math', 'is', 'eta quotient', 'eta', 'define the', 'define',
       'by math', 'by'], dtype='<U24')],
 true: 0, pred: 1
683:  a  MATH linear code over  MATH   with the weight distribution in 
 : [array(['with the', 'with', 'weight distribution', 'weight', 'the weight',
       'the', 'over math', 'over', 'math with', 'math linear', 'math',
       'linear code', 'linear', 'in', 'distribution in', 'distribution',
       'code over', 'code'], dtype='<U24')],
 true: 0, pred: 1
696:  following estimates hold for all   MATH  : MATH  Thus by shrinking the 
 : [array(['thus', 'the', 'math thus', 'math math', 'math', 'hold', 'for all',
       'for', 'following', 'estimates', 'by', 'all math', 'all'],
      dtype='<U24')],
 true: 1, pred: 0
697:  a  two-weight linear code over  MATH  with parameters MATH  and the 
 : [array(['with parameters', 'with', 'weight linear', 'weight', 'two weight',
       'two', 'the', 'parameters math', 'parameters', 'over math', 'over',
       'math with', 'math and', 'math', 'linear code', 'linear',
       'code over', 'code', 'and the', 'and'], dtype='<U24')],
 true: 0, pred: 1
706:  the wedge becomes  MATH  where  MATH   The shock front  MATH  becomes 
 : [array(['where math', 'where', 'wedge', 'the wedge', 'the shock', 'the',
       'shock front', 'shock', 'math where', 'math the', 'math becomes',
       'math', 'front math', 'front', 'becomes math', 'becomes'],
      dtype='<U24')],
 true: 0, pred: 1
707:  complex numbers of absolute value   MATH   with  MATH  for all   MATH 
 : [array(['with math', 'with', 'value', 'of', 'numbers', 'math with',
       'math for', 'math', 'for all', 'for', 'complex', 'all math', 'all'],
      dtype='<U24')],
 true: 1, pred: 0
713:  if for every open set   MATH   we define the  MATH  Gagliardo 
 : [array(['we define', 'we', 'the math', 'the', 'set math', 'set',
       'open set', 'open', 'math we', 'math', 'if', 'for every', 'for',
       'every', 'define the', 'define'], dtype='<U24')],
 true: 1, pred: 0
724:  from  (3.7)  by observing that   MATH   and that  MATH  , we get 
 : [array(['we get', 'we', 'that math', 'that', 'observing that', 'observing',
       'math we', 'math and', 'math', 'get', 'from', 'by', 'and that',
       'and'], dtype='<U24')],
 true: 1, pred: 0
725:  seminorm  MATH  then the operator   MATH   arises as the first variation 
 : [array(['then the', 'then', 'the operator', 'the first', 'the', 'seminorm',
       'operator math', 'operator', 'math then', 'math', 'first',
       'as the', 'as'], dtype='<U24')],
 true: 1, pred: 0
728:  such that  MATH  The quantity   MATH   is the  MATH  Gagliardo seminorm, 
 : [array(['the math', 'the', 'that math', 'that', 'such that', 'such',
       'seminorm', 'quantity', 'math the', 'math is', 'math', 'is the',
       'is'], dtype='<U24')],
 true: 1, pred: 0
731:  the velocity field in  MATH ,   MATH   is the density with  MATH 
 : [array(['with math', 'with', 'velocity', 'the velocity', 'the',
       'math math', 'math is', 'math', 'is the', 'is', 'in math', 'in',
       'field'], dtype='<U24')],
 true: 1, pred: 0
739:  MATH   where  MATH  and   MATH  ,  MATH  are Euler's  φ  function 
 : [array(['where math', 'where', 'math where', 'math math', 'math are',
       'math and', 'math', 'function', 'euler', 'are', 'and math', 'and'],
      dtype='<U24')],
 true: 1, pred: 0
747:  MATH   for all  MATH  and   MATH  . By  (6.3) , we have  MATH 
 : [array(['we have', 'we', 'math for', 'math by', 'math and', 'math',
       'have math', 'have', 'for all', 'for', 'by we', 'by', 'and math',
       'and', 'all math', 'all'], dtype='<U24')],
 true: 1, pred: 0
748:  there exists  a unique solution  MATH   to the boundary value problem 
 : [array(['value problem', 'value', 'unique solution', 'unique', 'to the',
       'to', 'there exists', 'there', 'the boundary', 'the',
       'solution math', 'solution', 'problem', 'math to', 'math',
       'exists unique', 'exists', 'boundary value', 'boundary'],
      dtype='<U24')],
 true: 0, pred: 1
778:  there exist valid admissible weights   MATH   which are further applicable to 
 : [array(['which', 'weights', 'valid', 'to', 'there exist', 'there',
       'math which', 'math', 'further', 'exist', 'are', 'applicable',
       'admissible'], dtype='<U24')],
 true: 1, pred: 0
779:  front  φ  is eliminated: MATH  MATH   where  h  is the product 
 : [array(['where is', 'where', 'the', 'product', 'math where', 'math math',
       'math', 'is the', 'is', 'front'], dtype='<U24')],
 true: 1, pred: 0
789:  For each  MATH , the function   MATH   defines an additive character of 
 : [array(['the function', 'the', 'of', 'math the', 'math', 'function math',
       'function', 'for each', 'for', 'each math', 'each', 'character of',
       'character', 'an', 'additive character', 'additive'], dtype='<U24')],
 true: 1, pred: 0
791:  have  MATH  and  MATH , i.e.   MATH   is the complex conjugate of 
 : [array(['the complex', 'the', 'of', 'math math', 'math is', 'math and',
       'math', 'is the', 'is', 'have math', 'have', 'complex', 'and math',
       'and'], dtype='<U24')],
 true: 1, pred: 0
823:  MATH   of  MATH , we denote   MATH   the transformation matrix of the 
 : [array(['we denote', 'we', 'transformation', 'the', 'of the', 'of math',
       'of', 'matrix of', 'matrix', 'math we', 'math the', 'math of',
       'math', 'denote math', 'denote'], dtype='<U24')],
 true: 1, pred: 0
824:  we obtain  MATH  for all   MATH   with  MATH . Integration in   MATH 
 : [array(['with math', 'with', 'we obtain', 'we', 'obtain math', 'obtain',
       'math with', 'math for', 'math', 'in math', 'in', 'for all', 'for',
       'all math', 'all'], dtype='<U24')],
 true: 1, pred: 0
830:  MATH  constant-weight linear code over  MATH  ;
 : [array(['weight linear', 'weight', 'over math', 'over', 'math constant',
       'math', 'linear code', 'linear', 'constant weight', 'constant',
       'code over', 'code'], dtype='<U24')],
 true: 0, pred: 1
837:  end up with  MATH  where   MATH   . By going back to the 
 : [array(['with math', 'with', 'where math', 'where', 'up', 'to the', 'to',
       'the', 'math where', 'math by', 'math', 'going', 'end', 'by'],
      dtype='<U24')],
 true: 1, pred: 0
843:  jumping directly from the ball   MATH   to the final one   MATH 
 : [array(['to the', 'to', 'the', 'one', 'math to', 'math', 'from the',
       'from', 'directly'], dtype='<U24')],
 true: 1, pred: 0
850:  yields the following second derivative:   MATH   Thus MATH  Hence  MATH  with 
 : [array(['yields', 'with', 'thus math', 'thus', 'the following', 'the',
       'second', 'math with', 'math thus', 'math hence', 'math',
       'hence math', 'hence', 'following', 'derivative'], dtype='<U24')],
 true: 1, pred: 0
852:  functions  φ ,  ψ  we have  MATH   We also remind the notation 
 : [array(['we have', 'we also', 'we', 'the notation', 'the', 'notation',
       'math we', 'math', 'have math', 'have', 'functions', 'also'],
      dtype='<U24')],
 true: 1, pred: 0
854:  defining sets of  MATH  and   MATH   into short ones, we can 
 : [array(['we can', 'we', 'short', 'sets', 'of math', 'of', 'math into',
       'math and', 'math', 'into', 'defining', 'can', 'and math', 'and'],
      dtype='<U24')],
 true: 1, pred: 0
861:  Any closed minimal Willmore hypersurface   MATH  of MATH  with constant scalar 
 : [array(['with constant', 'with', 'willmore hypersurface', 'willmore',
       'scalar', 'of math', 'of', 'minimal willmore', 'minimal',
       'math with', 'math of', 'math', 'hypersurface math',
       'hypersurface', 'constant scalar', 'constant', 'closed minimal',
       'closed', 'any'], dtype='<U24')],
 true: 1, pred: 0
873:  be applicable weights, and solution   MATH   can be  MATH  near the 
 : [array(['weights', 'the', 'solution math', 'solution', 'near the', 'near',
       'math near', 'math can', 'math', 'can be', 'can', 'be math', 'be',
       'applicable', 'and'], dtype='<U24')],
 true: 1, pred: 0
875:  over  MATH with nonzero weights  MATH  and MATH  is equivalent to 
 : [array(['with', 'weights', 'to', 'over math', 'over', 'nonzero',
       'math with', 'math is', 'math and', 'math', 'is equivalent', 'is',
       'equivalent to', 'equivalent', 'and math', 'and'], dtype='<U24')],
 true: 1, pred: 0
879:  be the set of eigenvalues   MATH  satisfying (A.13) : MATH Let  MATH 
 : [array(['the set', 'the', 'set of', 'set', 'satisfying', 'of',
       'math satisfying', 'math let', 'math', 'let math', 'let',
       'eigenvalues math', 'eigenvalues', 'be the', 'be', '13'],
      dtype='<U24')],
 true: 1, pred: 0
887:  some positive numbers  a and  MATH  and every x,  then there 
 : [array(['there', 'then there', 'then', 'some positive', 'some', 'positive',
       'numbers', 'math and', 'math', 'every', 'and math', 'and every',
       'and'], dtype='<U24')],
 true: 1, pred: 0
889:  collection of the above eigenvalues:   MATH   Therefore, we can fulfill the 
 : [array(['we can', 'we', 'therefore we', 'therefore', 'the above', 'the',
       'of the', 'of', 'math therefore', 'math', 'eigenvalues math',
       'eigenvalues', 'can', 'above'], dtype='<U24')],
 true: 1, pred: 0
893:  constants  MATH ,  MATH ,  MATH ,  MATH ,   MATH  ,  MATH  and  MATH  satisfy  MATH 
 : [array(['satisfy', 'math satisfy', 'math math', 'math and', 'math',
       'constants math', 'constants', 'and math', 'and'], dtype='<U24')],
 true: 1, pred: 0
897:  Then there exists  a constant  MATH   depending only on the parameters 
 : [array(['there exists', 'there', 'then there', 'then', 'the', 'parameters',
       'only', 'on the', 'on', 'math depending', 'math', 'exists',
       'depending', 'constant math', 'constant'], dtype='<U24')],
 true: 1, pred: 0
900:  is eliminated:  MATH MATH  where   MATH   is the product of the 
 : [array(['where math', 'where', 'the', 'product of', 'product', 'of the',
       'of', 'math where', 'math math', 'math is', 'math', 'is the', 'is'],
      dtype='<U24')],
 true: 1, pred: 0
905: The weight   MATH   in  (4.1)  has simultaneous control 
 : [array(['weight math', 'weight', 'the weight', 'the', 'math in', 'math',
       'in', 'has'], dtype='<U24')],
 true: 1, pred: 0
926:  positive integer. A positive integer   MATH   is of  Niho-type  if   MATH 
 : [array(['type', 'positive integer', 'positive', 'of', 'niho', 'math is',
       'math', 'is of', 'is', 'integer math', 'integer', 'if math', 'if'],
      dtype='<U24')],
 true: 1, pred: 0
943: Let  MATH   , be bounded functions such that 
 : [array(['that', 'such that', 'such', 'math be', 'math', 'let math', 'let',
       'functions such', 'functions', 'bounded', 'be bounded', 'be'],
      dtype='<U24')],
 true: 1, pred: 0
955:  normal derivative at a point   MATH   on ∂Ω. Thus, the trace 
 : [array(['trace', 'thus the', 'thus', 'the trace', 'the', 'point math',
       'point', 'on', 'normal', 'math on', 'math', 'derivative', 'at'],
      dtype='<U24')],
 true: 1, pred: 0
960:  we have  MATH for all  MATH  .
 : [array(['we have', 'we', 'math for', 'math', 'have math', 'have',
       'for all', 'for', 'all math', 'all'], dtype='<U24')],
 true: 1, pred: 0
973:  single layer potential defined by   MATH   which, however, is not integrable 
 : [array(['which', 'single layer', 'single', 'potential', 'not',
       'math which', 'math', 'layer potential', 'layer', 'is not', 'is',
       'however', 'defined by', 'defined', 'by math', 'by'], dtype='<U24')],
 true: 1, pred: 0
975:  N  , then for any prime   MATH  ,  (4.2)  is satisfied if we 
 : [array(['we', 'then for', 'then', 'prime', 'math is', 'math', 'is',
       'if we', 'if', 'for any', 'for', 'any'], dtype='<U24')],
 true: 1, pred: 0
980:  MATH  . When  MATH , we call   MATH   a constant-weight code. Let   MATH 
 : [array(['when math', 'when', 'weight', 'we call', 'we', 'math when',
       'math we', 'math constant', 'math', 'let math', 'let',
       'constant weight', 'constant', 'code', 'call math', 'call'],
      dtype='<U24')],
 true: 1, pred: 0
982:  orderings of the primes dividing   MATH  .
 : [array(['the', 'primes', 'of the', 'of', 'math', 'dividing math',
       'dividing'], dtype='<U24')],
 true: 0, pred: 1
983:  solution represented by point  B ,  MATH   This means that, via this 
 : [array(['via', 'this means', 'this', 'that', 'solution represented',
       'solution', 'represented by', 'represented', 'point math', 'point',
       'means that', 'means', 'math this', 'math', 'by point', 'by'],
      dtype='<U24')],
 true: 0, pred: 1
985:  the estimate (we use that   MATH   and again  MATH ) MATH  where 
 : [array(['where', 'we use', 'we', 'use', 'the estimate', 'the', 'that math',
       'that', 'math where', 'math math', 'math and', 'math', 'estimate',
       'and', 'again'], dtype='<U24')],
 true: 1, pred: 0
997: If  MATH   is the weak transonic shock 
 : [array(['weak transonic', 'weak', 'transonic shock', 'transonic',
       'the weak', 'the', 'shock', 'math is', 'math', 'is the', 'is',
       'if math', 'if'], dtype='<U24')],
 true: 0, pred: 1
1007:  of  MATH  functions such that  MATH   For  MATH  , we obtain the 
 : [array(['we obtain', 'we', 'the', 'that math', 'that', 'such that', 'such',
       'of math', 'of', 'obtain the', 'obtain', 'math we', 'math for',
       'math', 'functions such', 'functions', 'for math', 'for'],
      dtype='<U24')],
 true: 1, pred: 0
1015:  operators  MATH  and  MATH  by  MATH   We note that  MATH  and 
 : [array(['we', 'that math', 'that', 'operators', 'note that', 'note',
       'math we', 'math by', 'math and', 'math', 'by math', 'by',
       'and math', 'and'], dtype='<U24')],
 true: 1, pred: 0
1017:  by applying the blow-up transformation   MATH  ,  K  becomes an infinite strip: 
 : [array(['up', 'transformation math', 'transformation', 'the',
       'math becomes', 'math', 'by applying', 'by', 'becomes',
       'applying the', 'applying', 'an'], dtype='<U24')],
 true: 1, pred: 0
